from __future__ import annotations

import json
import os
from dataclasses import dataclass
from pathlib import Path
from typing import cast

from .exploit_tiering import (
    TIER_EVIDENCE_MISSING,
    TIER_HIGH_SEVERITY_REQUIRES_T2,
    TIER_INVALID_VALUE,
    default_exploitability_tier,
    exploitability_tier_rank,
    has_exploit_artifact_reference,
    is_valid_exploitability_tier,
)
from .schema import JsonValue
from .stage import StageContext, StageOutcome


_ALLOWED_SUFFIXES = {
    ".json",
    ".log",
    ".txt",
    ".md",
    ".html",
}

_REASON_SCOPE_NOT_LAB_ONLY = "POLICY_SCOPE_NOT_LAB_ONLY"


def _read_profile(run_dir: Path) -> str:
    p = run_dir / "manifest.json"
    if not p.is_file():
        return "analysis"
    try:
        raw = cast(object, json.loads(p.read_text(encoding="utf-8")))
    except Exception:
        return "analysis"
    if not isinstance(raw, dict):
        return "analysis"
    prof_any = cast(dict[str, object], raw).get("profile")
    return prof_any if isinstance(prof_any, str) and prof_any else "analysis"


def _read_manifest(run_dir: Path) -> dict[str, object] | None:
    p = run_dir / "manifest.json"
    if not p.is_file():
        return None
    try:
        raw = cast(object, json.loads(p.read_text(encoding="utf-8")))
    except Exception:
        return None
    if not isinstance(raw, dict):
        return None
    return cast(dict[str, object], raw)


def _manifest_scope(manifest: dict[str, object] | None) -> str | None:
    if manifest is None:
        return None
    gate_any = manifest.get("exploit_gate")
    if not isinstance(gate_any, dict):
        return None
    scope_any = cast(dict[str, object], gate_any).get("scope")
    if not isinstance(scope_any, str) or not scope_any:
        return None
    return scope_any


def _load_report_json(run_dir: Path) -> dict[str, object] | None:
    p = run_dir / "report" / "report.json"
    if not p.is_file():
        return None
    try:
        raw = cast(object, json.loads(p.read_text(encoding="utf-8")))
    except Exception:
        return None
    if not isinstance(raw, dict):
        return None
    return cast(dict[str, object], raw)


def _tier_violation(token: str, target: str, note: str) -> dict[str, str]:
    return {
        "reason_code": token,
        "target": target,
        "note": note,
    }


def _collect_tier_violations(report: dict[str, object] | None) -> list[dict[str, str]]:
    if report is None:
        return []

    violations: list[dict[str, str]] = []

    findings_any = report.get("findings")
    if isinstance(findings_any, list):
        for i, finding_any in enumerate(cast(list[object], findings_any)):
            if not isinstance(finding_any, dict):
                continue
            finding = cast(dict[str, object], finding_any)
            disp = finding.get("disposition")
            sev = finding.get("severity")
            tier_any = finding.get("exploitability_tier")

            if tier_any is not None and not is_valid_exploitability_tier(tier_any):
                violations.append(
                    _tier_violation(
                        TIER_INVALID_VALUE,
                        f"findings[{i}].exploitability_tier",
                        "exploitability_tier is not one of the supported tier values.",
                    )
                )

            tier = (
                cast(str, tier_any)
                if is_valid_exploitability_tier(tier_any)
                else default_exploitability_tier(disposition=disp)
            )
            rank = exploitability_tier_rank(tier)

            evidence_any = finding.get("evidence")
            if (
                rank is not None
                and rank >= 2
                and not has_exploit_artifact_reference(evidence_any)
            ):
                violations.append(
                    _tier_violation(
                        TIER_EVIDENCE_MISSING,
                        f"findings[{i}]",
                        "Tier2+ finding requires exploit-stage artifact evidence.",
                    )
                )

            if (
                isinstance(sev, str)
                and sev in {"high", "critical"}
                and disp == "confirmed"
                and (rank is None or rank < 2)
            ):
                violations.append(
                    _tier_violation(
                        TIER_HIGH_SEVERITY_REQUIRES_T2,
                        f"findings[{i}]",
                        "High/Critical confirmed findings require tier dynamic_repro or exploitability_assessed.",
                    )
                )

    llm_any = report.get("llm_synthesis")
    if isinstance(llm_any, dict):
        claims_any = cast(dict[str, object], llm_any).get("claims")
        if isinstance(claims_any, list):
            for i, claim_any in enumerate(cast(list[object], claims_any)):
                if not isinstance(claim_any, dict):
                    continue
                claim = cast(dict[str, object], claim_any)
                tier_any = claim.get("exploitability_tier")

                if tier_any is not None and not is_valid_exploitability_tier(tier_any):
                    violations.append(
                        _tier_violation(
                            TIER_INVALID_VALUE,
                            f"llm_synthesis.claims[{i}].exploitability_tier",
                            "exploitability_tier is not one of the supported tier values.",
                        )
                    )

                tier = (
                    cast(str, tier_any)
                    if is_valid_exploitability_tier(tier_any)
                    else default_exploitability_tier(disposition="confirmed")
                )
                rank = exploitability_tier_rank(tier)
                refs_any = claim.get("evidence_refs")
                if (
                    rank is not None
                    and rank >= 2
                    and not has_exploit_artifact_reference(refs_any)
                ):
                    violations.append(
                        _tier_violation(
                            TIER_EVIDENCE_MISSING,
                            f"llm_synthesis.claims[{i}]",
                            "Tier2+ claim requires exploit-stage evidence_refs.",
                        )
                    )

    return sorted(
        violations,
        key=lambda item: (item["reason_code"], item["target"], item["note"]),
    )


def _iter_exploit_artifacts(run_dir: Path) -> list[Path]:
    stages_dir = run_dir / "stages"
    if not stages_dir.is_dir():
        return []

    targets: list[Path] = []
    for name in (
        "exploit_gate",
        "exploit_chain",
        "poc_validation",
        "exploit_policy",
    ):
        d = stages_dir / name
        if d.is_dir():
            targets.append(d)

    out: list[Path] = []
    for d in targets:
        for root, _dirs, files in os.walk(d):
            for fn in files:
                out.append(Path(root) / fn)
    return out


@dataclass(frozen=True)
class ExploitEvidencePolicyStage:
    @property
    def name(self) -> str:
        return "exploit_policy"

    def run(self, ctx: StageContext) -> StageOutcome:
        profile = _read_profile(ctx.run_dir)
        manifest = _read_manifest(ctx.run_dir)
        scope = _manifest_scope(manifest)
        report_obj = _load_report_json(ctx.run_dir)

        stage_dir = ctx.run_dir / "stages" / "exploit_policy"
        stage_dir.mkdir(parents=True, exist_ok=True)
        report_path = stage_dir / "policy.json"

        evidence: list[JsonValue] = [
            {"path": "manifest.json"},
            {"path": "stages/exploit_policy"},
            {"path": "stages/exploit_policy/policy.json"},
        ]

        if profile != "exploit":
            _ = report_path.write_text(
                json.dumps(
                    {
                        "profile": profile,
                        "status": "skipped",
                        "allowed_suffixes": sorted(_ALLOWED_SUFFIXES),
                        "scanned": [],
                        "forbidden": [],
                        "blocked": [],
                        "tier_violations": [],
                    },
                    indent=2,
                    sort_keys=True,
                    ensure_ascii=True,
                )
                + "\n",
                encoding="utf-8",
            )
            return StageOutcome(
                status="skipped",
                details={
                    "profile": profile,
                    "evidence": cast(list[JsonValue], cast(list[object], evidence)),
                },
                limitations=[
                    "Exploit evidence policy skipped: profile is not exploit."
                ],
            )

        scanned = _iter_exploit_artifacts(ctx.run_dir)
        forbidden: list[str] = []
        for p in scanned:
            rel = p.relative_to(ctx.run_dir).as_posix()
            suf = p.suffix.lower()
            if suf and suf not in _ALLOWED_SUFFIXES:
                forbidden.append(rel)

        blocked: list[dict[str, str]] = []
        if scope is not None and scope != "lab-only":
            blocked.append(
                {
                    "reason_code": _REASON_SCOPE_NOT_LAB_ONLY,
                    "target": "manifest.exploit_gate.scope",
                    "note": "Exploit policy requires exploit_gate.scope=lab-only.",
                }
            )

        tier_violations = _collect_tier_violations(report_obj)

        policy_status = "ok"
        if forbidden or blocked or tier_violations:
            policy_status = "failed"

        _ = report_path.write_text(
            json.dumps(
                {
                    "profile": profile,
                    "status": policy_status,
                    "allowed_suffixes": sorted(_ALLOWED_SUFFIXES),
                    "scanned": [p.relative_to(ctx.run_dir).as_posix() for p in scanned],
                    "forbidden": forbidden,
                    "blocked": blocked,
                    "tier_violations": tier_violations,
                },
                indent=2,
                sort_keys=True,
                ensure_ascii=True,
            )
            + "\n",
            encoding="utf-8",
        )

        if forbidden or blocked or tier_violations:
            blocked_reason_codes = sorted(
                {
                    cast(str, item.get("reason_code"))
                    for item in blocked + tier_violations
                    if item.get("reason_code")
                }
            )
            return StageOutcome(
                status="failed",
                details={
                    "profile": profile,
                    "forbidden": cast(list[JsonValue], cast(list[object], forbidden)),
                    "blocked": cast(list[JsonValue], cast(list[object], blocked)),
                    "tier_violations": cast(
                        list[JsonValue], cast(list[object], tier_violations)
                    ),
                    "blocked_reason_codes": cast(
                        list[JsonValue], cast(list[object], blocked_reason_codes)
                    ),
                    "evidence": cast(list[JsonValue], cast(list[object], evidence)),
                },
                limitations=[
                    "Exploit policy checks failed (forbidden artifacts, scope gate, or tier policy)."
                ],
            )

        return StageOutcome(
            status="ok",
            details={
                "profile": profile,
                "evidence": cast(list[JsonValue], cast(list[object], evidence)),
            },
            limitations=[],
        )
