from __future__ import annotations

import hashlib
import json
from dataclasses import dataclass
from pathlib import Path
from typing import cast

from .schema import JsonValue
from .stage import StageContext, StageOutcome


def _read_manifest(run_dir: Path) -> dict[str, object] | None:
    p = run_dir / "manifest.json"
    if not p.is_file():
        return None
    try:
        raw_obj = cast(object, json.loads(p.read_text(encoding="utf-8")))
    except Exception:
        return None
    if not isinstance(raw_obj, dict):
        return None
    return cast(dict[str, object], raw_obj)


def _profile_and_gate(
    manifest: dict[str, object] | None,
) -> tuple[str, dict[str, str] | None]:
    if not manifest:
        return "analysis", None
    prof_any = manifest.get("profile")
    profile = prof_any if isinstance(prof_any, str) and prof_any else "analysis"
    gate_any = manifest.get("exploit_gate")
    if not isinstance(gate_any, dict):
        return profile, None
    gate_obj = cast(dict[str, object], gate_any)
    flag = gate_obj.get("flag")
    att = gate_obj.get("attestation")
    scope = gate_obj.get("scope")
    if not (isinstance(flag, str) and isinstance(att, str) and isinstance(scope, str)):
        return profile, None
    if not (flag and att and scope):
        return profile, None
    return profile, {"flag": flag, "attestation": att, "scope": scope}


def _sha256_file(path: Path) -> str:
    h = hashlib.sha256()
    with path.open("rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()


def _canonical_input_identity(
    run_dir: Path, manifest: dict[str, object] | None
) -> dict[str, str]:
    keys = ("analyzed_input_sha256", "input_sha256", "source_input_sha256")
    if manifest is not None:
        for key in keys:
            raw = manifest.get(key)
            if isinstance(raw, str) and raw:
                return {
                    "path": "input/firmware.bin",
                    "sha256": raw,
                    "sha256_source": f"manifest.{key}",
                }

    fw = run_dir / "input" / "firmware.bin"
    if fw.is_file():
        return {
            "path": "input/firmware.bin",
            "sha256": _sha256_file(fw),
            "sha256_source": "run_dir.input/firmware.bin",
        }

    return {
        "path": "input/firmware.bin",
        "sha256": "",
        "sha256_source": "missing",
    }


@dataclass(frozen=True)
class ExploitGateStage:
    @property
    def name(self) -> str:
        return "exploit_gate"

    def run(self, ctx: StageContext) -> StageOutcome:
        manifest = _read_manifest(ctx.run_dir)
        profile, gate = _profile_and_gate(manifest)

        evidence: list[JsonValue] = [{"path": "manifest.json"}]
        if profile != "exploit":
            return StageOutcome(
                status="skipped",
                details={
                    "profile": profile,
                    "evidence": cast(list[JsonValue], cast(list[object], evidence)),
                },
                limitations=["Exploit stages skipped: profile is not exploit."],
            )
        if gate is None:
            return StageOutcome(
                status="failed",
                details={
                    "profile": profile,
                    "evidence": cast(list[JsonValue], cast(list[object], evidence)),
                },
                limitations=[
                    "Exploit profile requires exploit_gate fields (flag, attestation, scope)."
                ],
            )

        return StageOutcome(
            status="ok",
            details={
                "profile": profile,
                "exploit_gate": cast(
                    dict[str, JsonValue], cast(dict[str, object], gate)
                ),
                "evidence": cast(list[JsonValue], cast(list[object], evidence)),
            },
            limitations=[],
        )


@dataclass(frozen=True)
class ExploitChainStage:
    @property
    def name(self) -> str:
        return "exploit_chain"

    def run(self, ctx: StageContext) -> StageOutcome:
        manifest = _read_manifest(ctx.run_dir)
        profile, gate = _profile_and_gate(manifest)
        canonical_input = _canonical_input_identity(ctx.run_dir, manifest)

        stage_dir = ctx.run_dir / "stages" / "exploit_chain"
        stage_dir.mkdir(parents=True, exist_ok=True)
        milestones_path = stage_dir / "milestones.json"

        evidence: list[JsonValue] = [
            {"path": "manifest.json"},
            {"path": "stages/exploit_chain"},
            {"path": "stages/exploit_chain/milestones.json"},
        ]

        if profile != "exploit":
            _ = milestones_path.write_text(
                json.dumps(
                    {
                        "profile": profile,
                        "canonical_input": canonical_input,
                        "milestones": [],
                        "note": "exploit_chain skipped because profile is not exploit",
                    },
                    indent=2,
                    sort_keys=True,
                    ensure_ascii=True,
                )
                + "\n",
                encoding="utf-8",
            )
            return StageOutcome(
                status="skipped",
                details={
                    "profile": profile,
                    "evidence": cast(list[JsonValue], cast(list[object], evidence)),
                },
                limitations=["Exploit chain skipped: profile is not exploit."],
            )

        if gate is None:
            _ = milestones_path.write_text(
                json.dumps(
                    {
                        "profile": profile,
                        "canonical_input": canonical_input,
                        "milestones": [],
                        "note": "exploit_chain failed because exploit_gate is missing",
                    },
                    indent=2,
                    sort_keys=True,
                    ensure_ascii=True,
                )
                + "\n",
                encoding="utf-8",
            )
            return StageOutcome(
                status="failed",
                details={
                    "profile": profile,
                    "evidence": cast(list[JsonValue], cast(list[object], evidence)),
                },
                limitations=["Exploit chain blocked: exploit_gate is missing."],
            )

        milestones = [
            {
                "id": "reachability",
                "status": "ok",
                "note": "Workflow gated and running in isolated environment; reachability is assessed via existing extraction/inventory artifacts.",
            },
            {
                "id": "bounded_impact",
                "status": "partial",
                "note": "No weaponized exploit payload is executed by AIEdge; this stage records non-weaponized, audit-ready evidence only.",
            },
            {
                "id": "postcondition",
                "status": "ok",
                "note": "All artifacts remain run-relative and bounded; runtime isolation is enforced by container policy.",
            },
        ]

        _ = milestones_path.write_text(
            json.dumps(
                {
                    "profile": profile,
                    "canonical_input": canonical_input,
                    "exploit_gate": gate,
                    "milestones": milestones,
                },
                indent=2,
                sort_keys=True,
                ensure_ascii=True,
            )
            + "\n",
            encoding="utf-8",
        )

        return StageOutcome(
            status="ok",
            details={
                "profile": profile,
                "evidence": cast(list[JsonValue], cast(list[object], evidence)),
                "milestones": cast(list[JsonValue], cast(list[object], milestones)),
            },
            limitations=[],
        )
