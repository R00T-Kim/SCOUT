from __future__ import annotations

import importlib.util
import io
import json
import re
import textwrap
from contextlib import redirect_stderr, redirect_stdout
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from types import ModuleType
from typing import Callable, cast

from .schema import JsonValue
from .stage import StageContext, StageOutcome

_AUTOPOC_SCHEMA_VERSION = "exploit-autopoc-v1"
_DEFAULT_MAX_CANDIDATES = 3
_DEFAULT_REPRO = 3


def _utc_now() -> str:
    return (
        datetime.now(tz=timezone.utc)
        .replace(microsecond=0)
        .isoformat()
        .replace("+00:00", "Z")
    )


def _read_manifest(run_dir: Path) -> dict[str, object] | None:
    path = run_dir / "manifest.json"
    if not path.is_file():
        return None
    try:
        raw = cast(object, json.loads(path.read_text(encoding="utf-8")))
    except Exception:
        return None
    if not isinstance(raw, dict):
        return None
    return cast(dict[str, object], raw)


def _profile_and_gate(
    manifest: dict[str, object] | None,
) -> tuple[str, dict[str, str] | None]:
    if manifest is None:
        return "analysis", None
    profile_any = manifest.get("profile")
    profile = (
        profile_any if isinstance(profile_any, str) and profile_any else "analysis"
    )
    gate_any = manifest.get("exploit_gate")
    if not isinstance(gate_any, dict):
        return profile, None
    gate_obj = cast(dict[str, object], gate_any)
    flag = gate_obj.get("flag")
    att = gate_obj.get("attestation")
    scope = gate_obj.get("scope")
    if not (isinstance(flag, str) and isinstance(att, str) and isinstance(scope, str)):
        return profile, None
    if not (flag and att and scope):
        return profile, None
    return profile, {"flag": flag, "attestation": att, "scope": scope}


def _safe_chain_token(value: str) -> str:
    token = re.sub(r"[^A-Za-z0-9._:-]", "_", value.strip())
    if not token:
        return "autopoc_chain"
    return token


def _safe_filename_token(value: str) -> str:
    token = re.sub(r"[^A-Za-z0-9._-]", "_", value.strip())
    if not token:
        return "autopoc_chain"
    return token


def _safe_float(value: object, default: float = 0.0) -> float:
    if isinstance(value, bool):
        return default
    if isinstance(value, (int, float)):
        return float(value)
    if isinstance(value, str):
        try:
            return float(value)
        except ValueError:
            return default
    return default


def _priority_rank(value: object) -> int:
    if not isinstance(value, str):
        return 9
    if value == "high":
        return 0
    if value == "medium":
        return 1
    if value == "low":
        return 2
    return 9


def _load_candidates(run_dir: Path) -> list[dict[str, object]]:
    path = run_dir / "stages" / "findings" / "exploit_candidates.json"
    if not path.is_file():
        return []
    try:
        raw = cast(object, json.loads(path.read_text(encoding="utf-8")))
    except Exception:
        return []
    if not isinstance(raw, dict):
        return []
    candidates_any = cast(dict[str, object], raw).get("candidates")
    if not isinstance(candidates_any, list):
        return []
    out: list[dict[str, object]] = []
    for item_any in cast(list[object], candidates_any):
        if not isinstance(item_any, dict):
            continue
        obj = cast(dict[str, object], item_any)
        chain_id_any = obj.get("chain_id")
        if not isinstance(chain_id_any, str) or not chain_id_any:
            continue
        out.append(obj)
    return out


def _select_candidates(
    candidates: list[dict[str, object]], *, max_candidates: int
) -> list[dict[str, object]]:
    ranked = sorted(
        candidates,
        key=lambda item: (
            _priority_rank(item.get("priority")),
            -_safe_float(item.get("score"), default=0.0),
            str(item.get("chain_id", "")),
            str(item.get("candidate_id", "")),
        ),
    )
    if max_candidates <= 0:
        return []
    return ranked[:max_candidates]


def _load_exploit_runner_fn() -> Callable[[Path, Path, str, int], int] | None:
    runner_path = Path(__file__).resolve().parents[2] / "exploit_runner.py"
    if not runner_path.is_file():
        return None
    spec = importlib.util.spec_from_file_location(
        "_aiedge_exploit_runner", str(runner_path)
    )
    if spec is None or spec.loader is None:
        return None
    mod = importlib.util.module_from_spec(spec)
    cast(ModuleType, mod)
    spec.loader.exec_module(mod)
    fn_any = getattr(mod, "run_exploit", None)
    if not callable(fn_any):
        return None
    fn = cast(Callable[..., object], fn_any)

    def invoke(run_dir: Path, exploit_dir: Path, chain_id: str, repro: int) -> int:
        code_any = fn(
            run_dir=run_dir,
            exploit_dir=exploit_dir,
            chain_id=chain_id,
            repro=repro,
        )
        if isinstance(code_any, int):
            return int(code_any)
        return 1

    return invoke


def _plugin_source(
    *,
    chain_id: str,
    target_service: str,
    candidate_id: str,
    candidate_summary: str,
) -> str:
    chain_literal = json.dumps(chain_id)
    service_literal = json.dumps(target_service)
    candidate_literal = json.dumps(candidate_id)
    summary_literal = json.dumps(candidate_summary)
    return textwrap.dedent(
        f"""\
        from __future__ import annotations

        import hashlib
        import socket
        from datetime import datetime, timezone


        class PoCResult:
            def __init__(self, success: bool, proof_type: str, proof_evidence: str, timestamp: str) -> None:
                self.success = success
                self.proof_type = proof_type
                self.proof_evidence = proof_evidence
                self.timestamp = timestamp


        def _utc_now() -> str:
            return datetime.now(tz=timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")


        class PoC:
            chain_id = {chain_literal}
            target_service = {service_literal}

            def setup(self, target_ip: str, target_port: int, *, context: dict[str, object]) -> None:
                self.target_ip = target_ip
                self.target_port = target_port
                self.context = context

            def execute(self) -> PoCResult:
                timestamp = _utc_now()
                evidence_prefix = (
                    "autopoc_mode=deterministic_nonweaponized "
                    + "candidate_id="
                    + {candidate_literal}
                    + " summary="
                    + {summary_literal}
                    + " probe=tcp_banner"
                )

                try:
                    sock = socket.create_connection((self.target_ip, int(self.target_port)), timeout=2.0)
                    sock.settimeout(2.0)
                    try:
                        sock.sendall(b"\\r\\n")
                    except Exception:
                        pass
                    banner = sock.recv(512)
                    sock.close()
                    digest = hashlib.sha256(banner).hexdigest()
                    evidence = (
                        evidence_prefix
                        + f" port={{self.target_port}} bytes={{len(banner)}} readback_hash={{digest}}"
                    )
                except Exception as exc:
                    evidence = (
                        evidence_prefix
                        + f" port={{self.target_port}} bytes=0 readback_hash=none error={{type(exc).__name__}}:{{exc}}"
                    )

                return PoCResult(
                    success=False,
                    proof_type="arbitrary_read",
                    proof_evidence=evidence,
                    timestamp=timestamp,
                )

            def cleanup(self) -> None:
                return
        """
    )


def _candidate_text(value: object, *, fallback: str) -> str:
    if isinstance(value, str):
        trimmed = " ".join(value.split())
        if trimmed:
            return trimmed
    return fallback


def _target_service_for_candidate(candidate: dict[str, object]) -> str:
    families_any = candidate.get("families")
    families: list[str] = []
    if isinstance(families_any, list):
        families = [x for x in cast(list[object], families_any) if isinstance(x, str)]
    families_lower = " ".join(families).lower()
    if "ssh" in families_lower:
        return "ssh"
    if "http" in families_lower or "cgi" in families_lower:
        return "http"
    return "tcp"


def _safe_rel(run_dir: Path, path: Path) -> str:
    try:
        return path.resolve().relative_to(run_dir.resolve()).as_posix()
    except Exception:
        return str(path)


def _write_json(path: Path, payload: dict[str, JsonValue]) -> None:
    _ = path.write_text(
        json.dumps(payload, indent=2, sort_keys=True, ensure_ascii=True) + "\n",
        encoding="utf-8",
    )


@dataclass(frozen=True)
class ExploitAutoPoCStage:
    max_candidates: int = _DEFAULT_MAX_CANDIDATES
    repro: int = _DEFAULT_REPRO

    @property
    def name(self) -> str:
        return "exploit_autopoc"

    def run(self, ctx: StageContext) -> StageOutcome:
        run_dir = ctx.run_dir
        stage_dir = run_dir / "stages" / "exploit_autopoc"
        stage_dir.mkdir(parents=True, exist_ok=True)
        summary_path = stage_dir / "exploit_autopoc.json"
        plugins_dir = stage_dir / "generated_plugins"
        logs_dir = stage_dir / "runner_logs"
        plugins_dir.mkdir(parents=True, exist_ok=True)
        logs_dir.mkdir(parents=True, exist_ok=True)

        manifest = _read_manifest(run_dir)
        profile, gate = _profile_and_gate(manifest)
        base_payload: dict[str, JsonValue] = {
            "schema_version": _AUTOPOC_SCHEMA_VERSION,
            "generated_at": _utc_now(),
            "profile": profile,
            "config": {
                "max_candidates": int(max(0, self.max_candidates)),
                "repro": int(max(1, self.repro)),
            },
            "attempts": [],
            "summary": {
                "candidate_count": 0,
                "selected_count": 0,
                "attempted": 0,
                "runner_pass": 0,
                "runner_nonpass": 0,
                "bundle_count": 0,
            },
            "limitations": [],
        }

        evidence: list[JsonValue] = [
            {"path": "manifest.json"},
            {"path": "stages/exploit_autopoc"},
            {"path": "stages/exploit_autopoc/exploit_autopoc.json"},
        ]

        if profile != "exploit":
            payload = dict(base_payload)
            payload["status"] = "skipped"
            payload["limitations"] = cast(
                JsonValue,
                ["exploit_autopoc skipped: profile is not exploit."],
            )
            _write_json(summary_path, cast(dict[str, JsonValue], payload))
            return StageOutcome(
                status="skipped",
                details={
                    "profile": profile,
                    "summary": cast(dict[str, JsonValue], payload["summary"]),
                    "evidence": evidence,
                },
                limitations=["exploit_autopoc skipped: profile is not exploit."],
            )

        if gate is None:
            payload = dict(base_payload)
            payload["status"] = "failed"
            payload["limitations"] = cast(
                JsonValue,
                ["exploit_autopoc blocked: exploit_gate is missing or malformed."],
            )
            _write_json(summary_path, cast(dict[str, JsonValue], payload))
            return StageOutcome(
                status="failed",
                details={
                    "profile": profile,
                    "summary": cast(dict[str, JsonValue], payload["summary"]),
                    "evidence": evidence,
                },
                limitations=["exploit_autopoc blocked: exploit_gate is missing."],
            )

        if gate.get("scope") != "lab-only" or gate.get("attestation") != "authorized":
            payload = dict(base_payload)
            payload["status"] = "failed"
            payload["limitations"] = cast(
                JsonValue,
                [
                    "exploit_autopoc blocked: requires exploit_gate.scope=lab-only and exploit_gate.attestation=authorized."
                ],
            )
            payload["exploit_gate"] = cast(
                JsonValue, cast(dict[str, object], dict(gate))
            )
            _write_json(summary_path, cast(dict[str, JsonValue], payload))
            return StageOutcome(
                status="failed",
                details={
                    "profile": profile,
                    "summary": cast(dict[str, JsonValue], payload["summary"]),
                    "evidence": evidence,
                },
                limitations=[
                    "exploit_autopoc blocked: gate scope/attestation do not satisfy lab-only authorized policy."
                ],
            )

        runner = _load_exploit_runner_fn()
        if runner is None:
            payload = dict(base_payload)
            payload["status"] = "failed"
            payload["limitations"] = cast(
                JsonValue,
                ["exploit_autopoc blocked: exploit_runner.py run_exploit unavailable."],
            )
            _write_json(summary_path, cast(dict[str, JsonValue], payload))
            return StageOutcome(
                status="failed",
                details={
                    "profile": profile,
                    "summary": cast(dict[str, JsonValue], payload["summary"]),
                    "evidence": evidence,
                },
                limitations=["exploit_autopoc blocked: exploit runner unavailable."],
            )

        candidates_all = _load_candidates(run_dir)
        selected = _select_candidates(
            candidates_all, max_candidates=int(max(0, self.max_candidates))
        )

        if not selected:
            payload = dict(base_payload)
            payload["status"] = "skipped"
            payload["summary"] = cast(
                JsonValue,
                {
                    "candidate_count": len(candidates_all),
                    "selected_count": 0,
                    "attempted": 0,
                    "runner_pass": 0,
                    "runner_nonpass": 0,
                    "bundle_count": 0,
                },
            )
            payload["limitations"] = cast(
                JsonValue,
                [
                    "exploit_autopoc skipped: no chain-backed exploit candidates were available."
                ],
            )
            _write_json(summary_path, cast(dict[str, JsonValue], payload))
            return StageOutcome(
                status="skipped",
                details={
                    "profile": profile,
                    "summary": cast(dict[str, JsonValue], payload["summary"]),
                    "evidence": evidence,
                },
                limitations=[
                    "exploit_autopoc skipped: no chain-backed exploit candidates."
                ],
            )

        attempts: list[dict[str, JsonValue]] = []
        bundle_refs: list[str] = []
        limits: list[str] = []
        runner_pass = 0
        runner_nonpass = 0

        for idx, candidate in enumerate(selected, start=1):
            chain_raw = _candidate_text(candidate.get("chain_id"), fallback=f"auto-{idx}")
            chain_id = _safe_chain_token(chain_raw)
            candidate_id = _candidate_text(
                candidate.get("candidate_id"), fallback=f"candidate-{idx}"
            )
            summary = _candidate_text(
                candidate.get("summary"), fallback="autopoc generated probe"
            )
            plugin_name = _safe_filename_token(chain_id) + ".py"
            plugin_path = plugins_dir / plugin_name
            source = _plugin_source(
                chain_id=chain_id,
                target_service=_target_service_for_candidate(candidate),
                candidate_id=candidate_id,
                candidate_summary=summary,
            )
            _ = plugin_path.write_text(source, encoding="utf-8")

            runner_buf = io.StringIO()
            with redirect_stdout(runner_buf), redirect_stderr(runner_buf):
                rc = runner(
                    run_dir=run_dir,
                    exploit_dir=plugins_dir,
                    chain_id=chain_id,
                    repro=int(max(1, self.repro)),
                )
            runner_output = runner_buf.getvalue()

            log_path = logs_dir / f"{_safe_filename_token(chain_id)}.log"
            _ = log_path.write_text(runner_output, encoding="utf-8")

            safe_chain_dir = re.sub(r"[^A-Za-z0-9._-]", "_", chain_id.strip())
            if not safe_chain_dir:
                safe_chain_dir = "unknown"
            bundle_path = (
                run_dir
                / "exploits"
                / f"chain_{safe_chain_dir}"
                / "evidence_bundle.json"
            )
            bundle_rel = ""
            if bundle_path.is_file():
                bundle_rel = _safe_rel(run_dir, bundle_path)
                bundle_refs.append(bundle_rel)
                evidence.append({"path": bundle_rel})

            plugin_rel = _safe_rel(run_dir, plugin_path)
            log_rel = _safe_rel(run_dir, log_path)
            evidence.append({"path": plugin_rel})
            evidence.append({"path": log_rel})

            if rc == 0:
                runner_pass += 1
            else:
                runner_nonpass += 1

            attempt_obj: dict[str, JsonValue] = {
                "chain_id": chain_id,
                "candidate_id": candidate_id,
                "priority": _candidate_text(candidate.get("priority"), fallback="unknown"),
                "score": float(_safe_float(candidate.get("score"), default=0.0)),
                "plugin_path": plugin_rel,
                "runner_log": log_rel,
                "runner_exit_code": int(rc),
                "bundle_path": bundle_rel,
            }
            attempts.append(attempt_obj)

            if rc != 0:
                limits.append(
                    f"autopoc runner non-pass for chain_id={chain_id} (exit={rc})"
                )

        stage_status = "ok" if runner_nonpass == 0 else "partial"
        summary_payload: dict[str, JsonValue] = {
            "candidate_count": len(candidates_all),
            "selected_count": len(selected),
            "attempted": len(attempts),
            "runner_pass": int(runner_pass),
            "runner_nonpass": int(runner_nonpass),
            "bundle_count": len(bundle_refs),
        }

        payload: dict[str, JsonValue] = {
            "schema_version": _AUTOPOC_SCHEMA_VERSION,
            "generated_at": _utc_now(),
            "profile": profile,
            "exploit_gate": cast(JsonValue, cast(dict[str, object], dict(gate))),
            "status": stage_status,
            "config": {
                "max_candidates": int(max(0, self.max_candidates)),
                "repro": int(max(1, self.repro)),
            },
            "attempts": cast(list[JsonValue], cast(list[object], attempts)),
            "summary": summary_payload,
            "limitations": cast(
                list[JsonValue], cast(list[object], sorted(set(limits)))
            ),
        }
        _write_json(summary_path, payload)

        detail_summary: dict[str, JsonValue] = {
            "profile": profile,
            "summary": summary_payload,
            "attempts": cast(list[JsonValue], cast(list[object], attempts)),
            "bundle_refs": cast(list[JsonValue], cast(list[object], sorted(bundle_refs))),
            "evidence": cast(list[JsonValue], cast(list[object], evidence)),
        }
        outcome_status = "ok" if stage_status == "ok" else "partial"
        return StageOutcome(
            status=outcome_status,
            details=detail_summary,
            limitations=sorted(set(limits)),
        )
