from __future__ import annotations

import hashlib
import json
import subprocess
import sys
from pathlib import Path
from typing import cast


def _write_json(path: Path, payload: dict[str, object]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    _ = path.write_text(
        json.dumps(payload, indent=2, sort_keys=True, ensure_ascii=True) + "\n",
        encoding="utf-8",
    )


def _prepare_run_dir(tmp_path: Path) -> Path:
    run_dir = tmp_path / "run"
    _write_json(
        run_dir / "stages" / "dynamic_validation" / "network" / "interfaces.json",
        {
            "interfaces": [{"ifname": "target", "ipv4": ["198.51.100.10"]}],
            "iid": "fixture",
        },
    )
    _write_json(
        run_dir / "stages" / "dynamic_validation" / "network" / "ports.json",
        {
            "open_ports": [8080],
            "target_ip": "198.51.100.10",
        },
    )
    return run_dir


def _prepare_private_plugin(tmp_path: Path) -> tuple[Path, str, Path]:
    exploit_dir = tmp_path / "private_exploits"
    exploit_dir.mkdir(parents=True, exist_ok=True)
    chain_id = "ER-e50_v3.0.1:rce_cgi_injection"
    plugin_path = exploit_dir / "poc_fixture.py"
    _ = plugin_path.write_text(
        "\n".join(
            [
                "from __future__ import annotations",
                "",
                "from poc_skeletons.interface import PoCResult",
                "",
                "",
                "class PoC:",
                f"    chain_id = {chain_id!r}",
                "    target_service = 'http'",
                "",
                "    def setup(self, target_ip: str, target_port: int, *, context: dict[str, object]) -> None:",
                "        self.target_ip = target_ip",
                "        self.target_port = target_port",
                "        self.context = context",
                "",
                "    def execute(self) -> PoCResult:",
                "        evidence = 'token=abc123 password=hunter2 bearer secretTokenValue'",
                "        return PoCResult(success=True, proof_type='shell', proof_evidence=evidence, timestamp='2026-02-17T00:00:00Z')",
                "",
                "    def cleanup(self) -> None:",
                "        return",
            ]
        )
        + "\n",
        encoding="utf-8",
    )
    return exploit_dir, chain_id, plugin_path


def _run_runner(
    run_dir: Path, exploit_dir: Path, chain_id: str
) -> subprocess.CompletedProcess[str]:
    repo_root = Path(__file__).resolve().parents[1]
    return subprocess.run(
        [
            sys.executable,
            str(repo_root / "exploit_runner.py"),
            "--run-dir",
            str(run_dir),
            "--exploit-dir",
            str(exploit_dir),
            "--chain-id",
            chain_id,
            "--repro",
            "3",
        ],
        cwd=repo_root,
        text=True,
        capture_output=True,
        check=False,
    )


def test_exploit_runner_executes_private_plugin_and_captures_logs(
    tmp_path: Path,
) -> None:
    run_dir = _prepare_run_dir(tmp_path)
    exploit_dir, chain_id, _ = _prepare_private_plugin(tmp_path)

    res = _run_runner(run_dir, exploit_dir, chain_id)
    assert res.returncode == 0
    assert "[OK] exploit evidence captured:" in res.stdout

    chain_dir = run_dir / "exploits" / "chain_ER-e50_v3.0.1_rce_cgi_injection"
    for idx in (1, 2, 3):
        log_path = chain_dir / f"execution_log_{idx}.txt"
        assert log_path.is_file()
        text = log_path.read_text(encoding="utf-8")
        assert "password=[REDACTED]" in text
        assert "token=[REDACTED]" in text
        assert "bearer [REDACTED]" in text
        assert "hunter2" not in text
        assert "abc123" not in text


def test_exploit_runner_does_not_copy_python_source_into_run_dir(
    tmp_path: Path,
) -> None:
    run_dir = _prepare_run_dir(tmp_path)
    exploit_dir, chain_id, _ = _prepare_private_plugin(tmp_path)

    res = _run_runner(run_dir, exploit_dir, chain_id)
    assert res.returncode == 0

    chain_dir = run_dir / "exploits" / "chain_ER-e50_v3.0.1_rce_cgi_injection"
    copied_sources = list((run_dir / "exploits").rglob("*.py"))
    assert copied_sources == []

    bundle_text = (chain_dir / "evidence_bundle.json").read_text(encoding="utf-8")
    assert exploit_dir.as_posix() not in bundle_text


def test_exploit_runner_writes_plugin_sha256_and_bundle(tmp_path: Path) -> None:
    run_dir = _prepare_run_dir(tmp_path)
    exploit_dir, chain_id, plugin_path = _prepare_private_plugin(tmp_path)

    res = _run_runner(run_dir, exploit_dir, chain_id)
    assert res.returncode == 0

    chain_dir = run_dir / "exploits" / "chain_ER-e50_v3.0.1_rce_cgi_injection"
    sha_path = chain_dir / "poc_sha256.txt"
    assert sha_path.is_file()
    expected = hashlib.sha256(plugin_path.read_bytes()).hexdigest()
    assert sha_path.read_text(encoding="utf-8").strip() == expected

    pcap_path = chain_dir / "network_capture.pcap"
    assert pcap_path.is_file()

    bundle_obj = cast(
        dict[str, object],
        json.loads((chain_dir / "evidence_bundle.json").read_text("utf-8")),
    )
    assert bundle_obj["exploitability_tier"] == "dynamic_repro"
    reproducibility = cast(dict[str, object], bundle_obj["reproducibility"])
    assert reproducibility["status"] == "pass"
    assert reproducibility["reason_code"] == "repro_pass"
    attempts = cast(list[object], bundle_obj["attempts"])
    reason_codes = [cast(dict[str, object], item)["reason_code"] for item in attempts]
    assert reason_codes == ["attempt_pass", "attempt_pass", "attempt_pass"]
