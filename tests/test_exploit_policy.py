from __future__ import annotations

import json
from pathlib import Path
from typing import cast

from aiedge.run import create_run, run_subset
from aiedge.schema import empty_report


def _write_firmware(tmp_path: Path) -> Path:
    fw = tmp_path / "fw.bin"
    _ = fw.write_bytes(b"FW")
    return fw


def _set_profile_exploit(manifest_path: Path) -> None:
    obj = cast(dict[str, object], json.loads(manifest_path.read_text(encoding="utf-8")))
    obj["profile"] = "exploit"
    obj["exploit_gate"] = {
        "flag": "flag",
        "attestation": "authorized",
        "scope": "lab-only",
    }
    _ = manifest_path.write_text(
        json.dumps(obj, indent=2, sort_keys=True, ensure_ascii=True) + "\n",
        encoding="utf-8",
    )


def test_exploit_policy_is_skipped_in_analysis_profile(tmp_path: Path) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-policy-skip",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )
    rep = run_subset(info, ["exploit_policy"], time_budget_s=5, no_llm=True)
    assert rep.status in ("ok", "partial", "skipped")
    stage_json = info.run_dir / "stages" / "exploit_policy" / "stage.json"
    raw_obj = cast(object, json.loads(stage_json.read_text(encoding="utf-8")))
    assert cast(dict[str, object], raw_obj).get("status") == "skipped"


def test_exploit_policy_fails_on_forbidden_suffix(tmp_path: Path) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-policy-fail",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )
    _set_profile_exploit(info.manifest_path)

    exploit_dir = info.run_dir / "stages" / "exploit_chain"
    exploit_dir.mkdir(parents=True, exist_ok=True)
    _ = (exploit_dir / "payload.bin").write_bytes(b"X")

    rep = run_subset(info, ["exploit_policy"], time_budget_s=5, no_llm=True)
    assert rep.status in ("partial", "failed")

    stage_json = info.run_dir / "stages" / "exploit_policy" / "stage.json"
    raw_obj = cast(object, json.loads(stage_json.read_text(encoding="utf-8")))
    assert cast(dict[str, object], raw_obj).get("status") == "failed"


def test_exploit_policy_reports_ok_for_allowed_outputs(tmp_path: Path) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-policy-ok",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )
    _set_profile_exploit(info.manifest_path)

    rep = run_subset(
        info,
        ["exploit_gate", "exploit_chain", "exploit_policy"],
        time_budget_s=5,
        no_llm=True,
    )
    assert rep.status in ("ok", "partial")

    policy_json = info.run_dir / "stages" / "exploit_policy" / "policy.json"
    obj = cast(dict[str, object], json.loads(policy_json.read_text(encoding="utf-8")))
    assert obj.get("status") == "ok"
    assert obj.get("forbidden") == []


def test_exploit_policy_blocks_non_lab_scope(tmp_path: Path) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-policy-scope-block",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )
    _set_profile_exploit(info.manifest_path)

    manifest = cast(
        dict[str, object], json.loads(info.manifest_path.read_text(encoding="utf-8"))
    )
    gate = cast(dict[str, object], manifest.get("exploit_gate"))
    gate["scope"] = "broader-than-lab"
    _ = info.manifest_path.write_text(
        json.dumps(manifest, indent=2, sort_keys=True, ensure_ascii=True) + "\n",
        encoding="utf-8",
    )

    rep = run_subset(info, ["exploit_policy"], time_budget_s=5, no_llm=True)
    assert rep.status in ("partial", "failed")

    policy_json = info.run_dir / "stages" / "exploit_policy" / "policy.json"
    obj = cast(dict[str, object], json.loads(policy_json.read_text(encoding="utf-8")))
    assert obj.get("status") == "failed"
    blocked = cast(list[object], obj.get("blocked"))
    blocked_codes = sorted(
        cast(dict[str, str], item).get("reason_code", "")
        for item in blocked
        if isinstance(item, dict)
    )
    assert "POLICY_SCOPE_NOT_LAB_ONLY" in blocked_codes


def test_exploit_policy_fails_tier_validation(tmp_path: Path) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-policy-tier-fail",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )
    _set_profile_exploit(info.manifest_path)

    report = cast(dict[str, object], empty_report())
    report["findings"] = [
        {
            "id": "aiedge.findings.tier.invalid",
            "title": "Tier rule check",
            "severity": "high",
            "confidence": 0.9,
            "disposition": "confirmed",
            "exploitability_tier": "strong_static",
            "evidence": [{"path": "stages/findings/findings.json"}],
        }
    ]
    report_path = info.run_dir / "report" / "report.json"
    _ = report_path.write_text(
        json.dumps(report, indent=2, sort_keys=True, ensure_ascii=True) + "\n",
        encoding="utf-8",
    )

    rep = run_subset(info, ["exploit_policy"], time_budget_s=5, no_llm=True)
    assert rep.status in ("partial", "failed")

    policy_json = info.run_dir / "stages" / "exploit_policy" / "policy.json"
    obj = cast(dict[str, object], json.loads(policy_json.read_text(encoding="utf-8")))
    assert obj.get("status") == "failed"
    tier_violations = cast(list[object], obj.get("tier_violations"))
    codes = sorted(
        cast(dict[str, str], item).get("reason_code", "")
        for item in tier_violations
        if isinstance(item, dict)
    )
    assert "TIER_HIGH_SEVERITY_REQUIRES_T2" in codes
