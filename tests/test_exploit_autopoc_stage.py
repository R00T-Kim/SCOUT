from __future__ import annotations

import json
import re
from pathlib import Path
from typing import cast

from aiedge.run import create_run, run_subset


def _write_firmware(tmp_path: Path) -> Path:
    fw = tmp_path / "fw.bin"
    _ = fw.write_bytes(b"FW")
    return fw


def _set_profile_exploit(manifest_path: Path) -> None:
    obj = cast(dict[str, object], json.loads(manifest_path.read_text(encoding="utf-8")))
    obj["profile"] = "exploit"
    obj["exploit_gate"] = {
        "flag": "auto",
        "attestation": "authorized",
        "scope": "lab-only",
    }
    _ = manifest_path.write_text(
        json.dumps(obj, indent=2, sort_keys=True, ensure_ascii=True) + "\n",
        encoding="utf-8",
    )


def _write_chain_candidate(run_dir: Path) -> None:
    findings_dir = run_dir / "stages" / "findings"
    findings_dir.mkdir(parents=True, exist_ok=True)
    candidates_payload = {
        "schema_version": "exploit-candidates-v1",
        "summary": {
            "candidate_count": 1,
            "chain_backed": 1,
        },
        "candidates": [
            {
                "candidate_id": "candidate:demo",
                "chain_id": "heuristic_chain:ssh_auth_to_mgmt_cmd_exec",
                "priority": "high",
                "score": 0.91,
                "families": ["authenticated_mgmt_cmd_path", "cmd_exec_injection_risk"],
                "summary": "Demo chain candidate",
            }
        ],
    }
    _ = (findings_dir / "exploit_candidates.json").write_text(
        json.dumps(candidates_payload, indent=2, sort_keys=True, ensure_ascii=True)
        + "\n",
        encoding="utf-8",
    )


def _write_nonchain_candidate(run_dir: Path) -> None:
    findings_dir = run_dir / "stages" / "findings"
    findings_dir.mkdir(parents=True, exist_ok=True)
    candidates_payload = {
        "schema_version": "exploit-candidates-v1",
        "summary": {
            "candidate_count": 1,
            "chain_backed": 0,
        },
        "candidates": [
            {
                "candidate_id": "candidate:nonchain-demo",
                "priority": "medium",
                "score": 0.78,
                "families": ["cmd_exec_injection_risk"],
                "summary": "Non-chain candidate",
                "evidence_refs": ["stages/findings/exploit_candidates.json"],
            }
        ],
    }
    _ = (findings_dir / "exploit_candidates.json").write_text(
        json.dumps(candidates_payload, indent=2, sort_keys=True, ensure_ascii=True)
        + "\n",
        encoding="utf-8",
    )


def _write_llm_chain_synthesis_artifact(run_dir: Path) -> None:
    llm_dir = run_dir / "stages" / "llm_synthesis"
    llm_dir.mkdir(parents=True, exist_ok=True)
    payload = {
        "status": "ok",
        "summary": {
            "claims_emitted": 1,
            "llm_chain_attempted": True,
            "llm_chain_status": "ok",
            "llm_chain_claims": 1,
        },
        "claims": [
            {
                "claim_type": "llm_chain.llm_chain_http_cmd",
                "confidence": 0.84,
                "evidence_refs": ["stages/findings/exploit_candidates.json"],
                "value": {
                    "chain_id": "llm_chain_http_cmd",
                    "hypothesis": "LLM-derived chain hypothesis",
                    "impact": "remote command execution",
                    "attack_steps": ["step-1", "step-2"],
                    "preconditions": ["reachable service"],
                },
            }
        ],
    }
    _ = (llm_dir / "llm_synthesis.json").write_text(
        json.dumps(payload, indent=2, sort_keys=True, ensure_ascii=True) + "\n",
        encoding="utf-8",
    )


def test_exploit_autopoc_skips_when_profile_is_not_exploit(tmp_path: Path) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-autopoc-skip",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )

    rep = run_subset(info, ["exploit_autopoc"], time_budget_s=5, no_llm=True)
    assert rep.status in ("ok", "partial", "skipped")
    assert [r.stage for r in rep.stage_results] == ["exploit_autopoc"]
    assert rep.stage_results[0].status == "skipped"

    stage_json = info.run_dir / "stages" / "exploit_autopoc" / "stage.json"
    stage_obj = cast(
        dict[str, object],
        json.loads(stage_json.read_text(encoding="utf-8")),
    )
    assert stage_obj["status"] == "skipped"


def test_exploit_autopoc_generates_bundle_for_chain_candidate(tmp_path: Path) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-autopoc-generate",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )
    _set_profile_exploit(info.manifest_path)
    _write_chain_candidate(info.run_dir)

    rep = run_subset(info, ["exploit_autopoc"], time_budget_s=5, no_llm=True)
    assert rep.status in ("partial", "ok")
    assert [r.stage for r in rep.stage_results] == ["exploit_autopoc"]

    summary_path = info.run_dir / "stages" / "exploit_autopoc" / "exploit_autopoc.json"
    summary_obj = cast(
        dict[str, object],
        json.loads(summary_path.read_text(encoding="utf-8")),
    )
    assert summary_obj["status"] in ("partial", "ok")
    summary = cast(dict[str, object], summary_obj["summary"])
    assert summary["selected_count"] == 1
    assert summary["attempted"] == 1
    assert int(cast(int, summary["bundle_count"])) >= 1

    exploits_dir = info.run_dir / "exploits"
    chain_dirs = [p for p in exploits_dir.iterdir() if p.is_dir() and p.name.startswith("chain_")]
    assert chain_dirs
    bundle_path = chain_dirs[0] / "evidence_bundle.json"
    assert bundle_path.is_file()
    bundle = cast(dict[str, object], json.loads(bundle_path.read_text(encoding="utf-8")))
    attempts = cast(list[object], bundle["attempts"])
    assert len(attempts) == 3
    first = cast(dict[str, object], attempts[0])
    assert first["proof_type"] == "arbitrary_read"


def test_exploit_autopoc_prefers_llm_generated_plugin_when_available(
    tmp_path: Path, monkeypatch
) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-autopoc-llm",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )
    _set_profile_exploit(info.manifest_path)
    _write_chain_candidate(info.run_dir)

    import aiedge.exploit_autopoc as autopoc

    llm_source = """
from __future__ import annotations

import hashlib
import socket
from datetime import datetime, timezone

class PoCResult:
    def __init__(self, success: bool, proof_type: str, proof_evidence: str, timestamp: str) -> None:
        self.success = success
        self.proof_type = proof_type
        self.proof_evidence = proof_evidence
        self.timestamp = timestamp

class PoC:
    chain_id = "heuristic_chain:ssh_auth_to_mgmt_cmd_exec"
    target_service = "tcp"
    def setup(self, target_ip: str, target_port: int, *, context: dict[str, object]) -> None:
        self.target_ip = target_ip
        self.target_port = target_port
        self.context = context
    def execute(self) -> PoCResult:
        ts = datetime.now(tz=timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")
        probe = b"llm-probe"
        digest = hashlib.sha256(probe).hexdigest()
        ev = "autopoc_mode=llm_nonweaponized candidate_id=candidate:demo summary=Demo chain candidate probe=tcp_banner readback_hash=" + digest
        return PoCResult(success=True, proof_type="arbitrary_read", proof_evidence=ev, timestamp=ts)
    def cleanup(self) -> None:
        return
""".strip() + "\n"

    def fake_codex_exec(*, prompt: str, run_dir: Path, timeout_s: float) -> dict[str, object]:
        _ = prompt, run_dir, timeout_s
        return {
            "status": "ok",
            "stdout": llm_source,
            "stderr": "",
            "argv": ["codex", "exec"],
            "attempts": [{"argv": ["codex", "exec"], "returncode": 0}],
            "returncode": 0,
        }

    def fake_runner(run_dir: Path, exploit_dir: Path, chain_id: str, repro: int) -> int:
        plugin_path = exploit_dir / "heuristic_chain_ssh_auth_to_mgmt_cmd_exec.py"
        plugin_text = plugin_path.read_text(encoding="utf-8")
        assert "autopoc_mode=llm_nonweaponized" in plugin_text
        safe_chain = re.sub(r"[^A-Za-z0-9._-]", "_", chain_id.strip())
        chain_dir = run_dir / "exploits" / f"chain_{safe_chain}"
        chain_dir.mkdir(parents=True, exist_ok=True)
        _ = (chain_dir / "evidence_bundle.json").write_text(
            json.dumps({"attempts": [], "reproducibility": {"requested": repro}})
            + "\n",
            encoding="utf-8",
        )
        return 0

    monkeypatch.setattr(autopoc, "_run_codex_exec", fake_codex_exec)
    monkeypatch.setattr(autopoc, "_load_exploit_runner_fn", lambda: fake_runner)

    rep = run_subset(info, ["exploit_autopoc"], time_budget_s=5, no_llm=False)
    assert rep.status in ("ok", "partial")
    assert [r.stage for r in rep.stage_results] == ["exploit_autopoc"]

    summary_obj = cast(
        dict[str, object],
        json.loads(
            (info.run_dir / "stages" / "exploit_autopoc" / "exploit_autopoc.json").read_text(
                encoding="utf-8"
            )
        ),
    )
    summary = cast(dict[str, object], summary_obj["summary"])
    assert summary["llm_generated"] == 1
    assert summary["template_fallback"] == 0
    attempts_any = cast(list[object], summary_obj["attempts"])
    assert attempts_any
    first = cast(dict[str, object], attempts_any[0])
    assert first["generator"] == "llm"
    llm_meta = cast(str, first["llm_meta_path"])
    assert llm_meta
    assert (info.run_dir / llm_meta).is_file()


def test_template_plugin_supports_readback_fallback(tmp_path: Path) -> None:
    import aiedge.exploit_autopoc as autopoc

    run_dir = tmp_path / "run"
    target_file = run_dir / "stages" / "findings" / "probe.txt"
    target_file.parent.mkdir(parents=True, exist_ok=True)
    _ = target_file.write_text("firmware-readback-evidence\n", encoding="utf-8")

    source = autopoc._plugin_source(
        chain_id="heuristic_chain:ssh_auth_to_mgmt_cmd_exec",
        target_service="tcp",
        candidate_id="candidate:demo",
        candidate_summary="Demo chain candidate",
        fallback_read_rel="stages/findings/probe.txt",
    )

    env: dict[str, object] = {}
    exec(source, env)
    poc_cls = cast(type[object], env["PoC"])
    poc = poc_cls()
    setup_fn = getattr(poc, "setup")
    execute_fn = getattr(poc, "execute")
    setup_fn("256.256.256.256", 80, context={"run_dir": str(run_dir)})
    result = execute_fn()

    assert bool(getattr(result, "success")) is True
    evidence = str(getattr(result, "proof_evidence"))
    assert "fallback=file_read" in evidence
    assert "readback_hash=" in evidence


def test_exploit_autopoc_uses_llm_chain_candidates_when_present(
    tmp_path: Path, monkeypatch
) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-autopoc-llm-chain-seed",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )
    _set_profile_exploit(info.manifest_path)
    _write_nonchain_candidate(info.run_dir)
    _write_llm_chain_synthesis_artifact(info.run_dir)

    import aiedge.exploit_autopoc as autopoc

    def fake_runner(run_dir: Path, exploit_dir: Path, chain_id: str, repro: int) -> int:
        _ = exploit_dir
        assert chain_id == "llm_chain_http_cmd"
        safe_chain = re.sub(r"[^A-Za-z0-9._-]", "_", chain_id.strip())
        chain_dir = run_dir / "exploits" / f"chain_{safe_chain}"
        chain_dir.mkdir(parents=True, exist_ok=True)
        _ = (chain_dir / "evidence_bundle.json").write_text(
            json.dumps({"attempts": [], "reproducibility": {"requested": repro}})
            + "\n",
            encoding="utf-8",
        )
        return 0

    monkeypatch.setattr(autopoc, "_load_exploit_runner_fn", lambda: fake_runner)

    rep = run_subset(info, ["exploit_autopoc"], time_budget_s=5, no_llm=True)
    assert rep.status in ("ok", "partial")
    assert [r.stage for r in rep.stage_results] == ["exploit_autopoc"]

    summary_obj = cast(
        dict[str, object],
        json.loads(
            (info.run_dir / "stages" / "exploit_autopoc" / "exploit_autopoc.json").read_text(
                encoding="utf-8"
            )
        ),
    )
    summary = cast(dict[str, object], summary_obj["summary"])
    assert int(cast(int, summary["llm_seeded_candidates"])) >= 1
    assert int(cast(int, summary["selected_count"])) == 1
    attempts = cast(list[object], summary_obj["attempts"])
    assert attempts
    first = cast(dict[str, object], attempts[0])
    assert first["chain_id"] == "llm_chain_http_cmd"


def test_candidate_prompt_context_includes_refs_and_snippets(tmp_path: Path) -> None:
    import aiedge.exploit_autopoc as autopoc

    run_dir = tmp_path / "run"
    evidence_file = run_dir / "stages" / "findings" / "hint.txt"
    evidence_file.parent.mkdir(parents=True, exist_ok=True)
    _ = evidence_file.write_text(
        "nvram_get(service_name) then system(cmd)\nmanage_by_gui=1\n",
        encoding="utf-8",
    )

    candidate: dict[str, object] = {
        "summary": "RCE path candidate",
        "attack_hypothesis": "nvram_get -> system",
        "families": ["cmd_exec_injection_risk"],
        "evidence_refs": ["stages/findings/hint.txt"],
    }
    context, refs = autopoc._candidate_prompt_context(run_dir, candidate)
    assert "summary: RCE path candidate" in context
    assert "hypothesis: nvram_get -> system" in context
    assert "evidence_refs" in context
    assert "snippet[stages/findings/hint.txt]" in context
    assert refs == ["stages/findings/hint.txt"]


def test_exploit_autopoc_promotes_non_chain_candidates_when_needed(
    tmp_path: Path, monkeypatch
) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-autopoc-promoted-non-chain",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )
    _set_profile_exploit(info.manifest_path)
    _write_nonchain_candidate(info.run_dir)

    import aiedge.exploit_autopoc as autopoc

    def fake_runner(run_dir: Path, exploit_dir: Path, chain_id: str, repro: int) -> int:
        _ = exploit_dir
        assert chain_id.startswith("synthetic_chain:")
        safe_chain = re.sub(r"[^A-Za-z0-9._-]", "_", chain_id.strip())
        chain_dir = run_dir / "exploits" / f"chain_{safe_chain}"
        chain_dir.mkdir(parents=True, exist_ok=True)
        _ = (chain_dir / "evidence_bundle.json").write_text(
            json.dumps({"attempts": [], "reproducibility": {"requested": repro}})
            + "\n",
            encoding="utf-8",
        )
        return 0

    monkeypatch.setattr(autopoc, "_load_exploit_runner_fn", lambda: fake_runner)

    rep = run_subset(info, ["exploit_autopoc"], time_budget_s=5, no_llm=True)
    assert rep.status in ("ok", "partial")
    assert [r.stage for r in rep.stage_results] == ["exploit_autopoc"]

    summary_obj = cast(
        dict[str, object],
        json.loads(
            (info.run_dir / "stages" / "exploit_autopoc" / "exploit_autopoc.json").read_text(
                encoding="utf-8"
            )
        ),
    )
    summary = cast(dict[str, object], summary_obj["summary"])
    assert int(cast(int, summary["promoted_non_chain_candidates"])) >= 1
    assert int(cast(int, summary["selected_count"])) == 1
    attempts = cast(list[object], summary_obj["attempts"])
    assert attempts
    first = cast(dict[str, object], attempts[0])
    assert cast(str, first["chain_id"]).startswith("synthetic_chain:")
