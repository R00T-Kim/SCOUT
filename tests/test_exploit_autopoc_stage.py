from __future__ import annotations

import json
from pathlib import Path
from typing import cast

from aiedge.run import create_run, run_subset


def _write_firmware(tmp_path: Path) -> Path:
    fw = tmp_path / "fw.bin"
    _ = fw.write_bytes(b"FW")
    return fw


def _set_profile_exploit(manifest_path: Path) -> None:
    obj = cast(dict[str, object], json.loads(manifest_path.read_text(encoding="utf-8")))
    obj["profile"] = "exploit"
    obj["exploit_gate"] = {
        "flag": "auto",
        "attestation": "authorized",
        "scope": "lab-only",
    }
    _ = manifest_path.write_text(
        json.dumps(obj, indent=2, sort_keys=True, ensure_ascii=True) + "\n",
        encoding="utf-8",
    )


def test_exploit_autopoc_skips_when_profile_is_not_exploit(tmp_path: Path) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-autopoc-skip",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )

    rep = run_subset(info, ["exploit_autopoc"], time_budget_s=5, no_llm=True)
    assert rep.status in ("ok", "partial", "skipped")
    assert [r.stage for r in rep.stage_results] == ["exploit_autopoc"]
    assert rep.stage_results[0].status == "skipped"

    stage_json = info.run_dir / "stages" / "exploit_autopoc" / "stage.json"
    stage_obj = cast(
        dict[str, object],
        json.loads(stage_json.read_text(encoding="utf-8")),
    )
    assert stage_obj["status"] == "skipped"


def test_exploit_autopoc_generates_bundle_for_chain_candidate(tmp_path: Path) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-autopoc-generate",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )
    _set_profile_exploit(info.manifest_path)

    findings_dir = info.run_dir / "stages" / "findings"
    findings_dir.mkdir(parents=True, exist_ok=True)
    candidates_payload = {
        "schema_version": "exploit-candidates-v1",
        "summary": {
            "candidate_count": 1,
            "chain_backed": 1,
        },
        "candidates": [
            {
                "candidate_id": "candidate:demo",
                "chain_id": "heuristic_chain:ssh_auth_to_mgmt_cmd_exec",
                "priority": "high",
                "score": 0.91,
                "families": ["authenticated_mgmt_cmd_path", "cmd_exec_injection_risk"],
                "summary": "Demo chain candidate",
            }
        ],
    }
    _ = (findings_dir / "exploit_candidates.json").write_text(
        json.dumps(candidates_payload, indent=2, sort_keys=True, ensure_ascii=True)
        + "\n",
        encoding="utf-8",
    )

    rep = run_subset(info, ["exploit_autopoc"], time_budget_s=5, no_llm=True)
    assert rep.status in ("partial", "ok")
    assert [r.stage for r in rep.stage_results] == ["exploit_autopoc"]

    summary_path = info.run_dir / "stages" / "exploit_autopoc" / "exploit_autopoc.json"
    summary_obj = cast(
        dict[str, object],
        json.loads(summary_path.read_text(encoding="utf-8")),
    )
    assert summary_obj["status"] in ("partial", "ok")
    summary = cast(dict[str, object], summary_obj["summary"])
    assert summary["selected_count"] == 1
    assert summary["attempted"] == 1
    assert int(cast(int, summary["bundle_count"])) >= 1

    exploits_dir = info.run_dir / "exploits"
    chain_dirs = [p for p in exploits_dir.iterdir() if p.is_dir() and p.name.startswith("chain_")]
    assert chain_dirs
    bundle_path = chain_dirs[0] / "evidence_bundle.json"
    assert bundle_path.is_file()
    bundle = cast(dict[str, object], json.loads(bundle_path.read_text(encoding="utf-8")))
    attempts = cast(list[object], bundle["attempts"])
    assert len(attempts) == 3
    first = cast(dict[str, object], attempts[0])
    assert first["proof_type"] == "arbitrary_read"
