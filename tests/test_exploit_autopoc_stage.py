from __future__ import annotations

import json
import re
from pathlib import Path
from typing import cast

from aiedge.run import create_run, run_subset


def _write_firmware(tmp_path: Path) -> Path:
    fw = tmp_path / "fw.bin"
    _ = fw.write_bytes(b"FW")
    return fw


def _set_profile_exploit(manifest_path: Path) -> None:
    obj = cast(dict[str, object], json.loads(manifest_path.read_text(encoding="utf-8")))
    obj["profile"] = "exploit"
    obj["exploit_gate"] = {
        "flag": "auto",
        "attestation": "authorized",
        "scope": "lab-only",
    }
    _ = manifest_path.write_text(
        json.dumps(obj, indent=2, sort_keys=True, ensure_ascii=True) + "\n",
        encoding="utf-8",
    )


def _write_chain_candidate(run_dir: Path) -> None:
    findings_dir = run_dir / "stages" / "findings"
    findings_dir.mkdir(parents=True, exist_ok=True)
    candidates_payload = {
        "schema_version": "exploit-candidates-v1",
        "summary": {
            "candidate_count": 1,
            "chain_backed": 1,
        },
        "candidates": [
            {
                "candidate_id": "candidate:demo",
                "chain_id": "heuristic_chain:ssh_auth_to_mgmt_cmd_exec",
                "priority": "high",
                "score": 0.91,
                "families": ["authenticated_mgmt_cmd_path", "cmd_exec_injection_risk"],
                "summary": "Demo chain candidate",
            }
        ],
    }
    _ = (findings_dir / "exploit_candidates.json").write_text(
        json.dumps(candidates_payload, indent=2, sort_keys=True, ensure_ascii=True)
        + "\n",
        encoding="utf-8",
    )


def test_exploit_autopoc_skips_when_profile_is_not_exploit(tmp_path: Path) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-autopoc-skip",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )

    rep = run_subset(info, ["exploit_autopoc"], time_budget_s=5, no_llm=True)
    assert rep.status in ("ok", "partial", "skipped")
    assert [r.stage for r in rep.stage_results] == ["exploit_autopoc"]
    assert rep.stage_results[0].status == "skipped"

    stage_json = info.run_dir / "stages" / "exploit_autopoc" / "stage.json"
    stage_obj = cast(
        dict[str, object],
        json.loads(stage_json.read_text(encoding="utf-8")),
    )
    assert stage_obj["status"] == "skipped"


def test_exploit_autopoc_generates_bundle_for_chain_candidate(tmp_path: Path) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-autopoc-generate",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )
    _set_profile_exploit(info.manifest_path)
    _write_chain_candidate(info.run_dir)

    rep = run_subset(info, ["exploit_autopoc"], time_budget_s=5, no_llm=True)
    assert rep.status in ("partial", "ok")
    assert [r.stage for r in rep.stage_results] == ["exploit_autopoc"]

    summary_path = info.run_dir / "stages" / "exploit_autopoc" / "exploit_autopoc.json"
    summary_obj = cast(
        dict[str, object],
        json.loads(summary_path.read_text(encoding="utf-8")),
    )
    assert summary_obj["status"] in ("partial", "ok")
    summary = cast(dict[str, object], summary_obj["summary"])
    assert summary["selected_count"] == 1
    assert summary["attempted"] == 1
    assert int(cast(int, summary["bundle_count"])) >= 1

    exploits_dir = info.run_dir / "exploits"
    chain_dirs = [p for p in exploits_dir.iterdir() if p.is_dir() and p.name.startswith("chain_")]
    assert chain_dirs
    bundle_path = chain_dirs[0] / "evidence_bundle.json"
    assert bundle_path.is_file()
    bundle = cast(dict[str, object], json.loads(bundle_path.read_text(encoding="utf-8")))
    attempts = cast(list[object], bundle["attempts"])
    assert len(attempts) == 3
    first = cast(dict[str, object], attempts[0])
    assert first["proof_type"] == "arbitrary_read"


def test_exploit_autopoc_prefers_llm_generated_plugin_when_available(
    tmp_path: Path, monkeypatch
) -> None:
    fw = _write_firmware(tmp_path)
    info = create_run(
        str(fw),
        case_id="case-autopoc-llm",
        ack_authorization=True,
        runs_root=tmp_path / "runs",
    )
    _set_profile_exploit(info.manifest_path)
    _write_chain_candidate(info.run_dir)

    import aiedge.exploit_autopoc as autopoc

    llm_source = """
from __future__ import annotations

import hashlib
import socket
from datetime import datetime, timezone

class PoCResult:
    def __init__(self, success: bool, proof_type: str, proof_evidence: str, timestamp: str) -> None:
        self.success = success
        self.proof_type = proof_type
        self.proof_evidence = proof_evidence
        self.timestamp = timestamp

class PoC:
    chain_id = "heuristic_chain:ssh_auth_to_mgmt_cmd_exec"
    target_service = "tcp"
    def setup(self, target_ip: str, target_port: int, *, context: dict[str, object]) -> None:
        self.target_ip = target_ip
        self.target_port = target_port
        self.context = context
    def execute(self) -> PoCResult:
        ts = datetime.now(tz=timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")
        probe = b"llm-probe"
        digest = hashlib.sha256(probe).hexdigest()
        ev = "autopoc_mode=llm_nonweaponized candidate_id=candidate:demo summary=Demo chain candidate probe=tcp_banner readback_hash=" + digest
        return PoCResult(success=True, proof_type="arbitrary_read", proof_evidence=ev, timestamp=ts)
    def cleanup(self) -> None:
        return
""".strip() + "\n"

    def fake_codex_exec(*, prompt: str, run_dir: Path, timeout_s: float) -> dict[str, object]:
        _ = prompt, run_dir, timeout_s
        return {
            "status": "ok",
            "stdout": llm_source,
            "stderr": "",
            "argv": ["codex", "exec"],
            "attempts": [{"argv": ["codex", "exec"], "returncode": 0}],
            "returncode": 0,
        }

    def fake_runner(run_dir: Path, exploit_dir: Path, chain_id: str, repro: int) -> int:
        plugin_path = exploit_dir / "heuristic_chain_ssh_auth_to_mgmt_cmd_exec.py"
        plugin_text = plugin_path.read_text(encoding="utf-8")
        assert "autopoc_mode=llm_nonweaponized" in plugin_text
        safe_chain = re.sub(r"[^A-Za-z0-9._-]", "_", chain_id.strip())
        chain_dir = run_dir / "exploits" / f"chain_{safe_chain}"
        chain_dir.mkdir(parents=True, exist_ok=True)
        _ = (chain_dir / "evidence_bundle.json").write_text(
            json.dumps({"attempts": [], "reproducibility": {"requested": repro}})
            + "\n",
            encoding="utf-8",
        )
        return 0

    monkeypatch.setattr(autopoc, "_run_codex_exec", fake_codex_exec)
    monkeypatch.setattr(autopoc, "_load_exploit_runner_fn", lambda: fake_runner)

    rep = run_subset(info, ["exploit_autopoc"], time_budget_s=5, no_llm=False)
    assert rep.status in ("ok", "partial")
    assert [r.stage for r in rep.stage_results] == ["exploit_autopoc"]

    summary_obj = cast(
        dict[str, object],
        json.loads(
            (info.run_dir / "stages" / "exploit_autopoc" / "exploit_autopoc.json").read_text(
                encoding="utf-8"
            )
        ),
    )
    summary = cast(dict[str, object], summary_obj["summary"])
    assert summary["llm_generated"] == 1
    assert summary["template_fallback"] == 0
    attempts_any = cast(list[object], summary_obj["attempts"])
    assert attempts_any
    first = cast(dict[str, object], attempts_any[0])
    assert first["generator"] == "llm"
    llm_meta = cast(str, first["llm_meta_path"])
    assert llm_meta
    assert (info.run_dir / llm_meta).is_file()
