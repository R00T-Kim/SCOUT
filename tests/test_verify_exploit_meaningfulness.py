from __future__ import annotations

import json
import subprocess
import sys
from pathlib import Path
from typing import cast


def _run_verifier(run_dir: Path) -> subprocess.CompletedProcess[str]:
    repo_root = Path(__file__).resolve().parents[1]
    return subprocess.run(
        [
            sys.executable,
            str(repo_root / "scripts" / "verify_exploit_meaningfulness.py"),
            "--run-dir",
            str(run_dir),
        ],
        cwd=repo_root,
        text=True,
        capture_output=True,
        check=False,
    )


def _write_chain_bundle(
    run_dir: Path,
    *,
    chain_name: str = "chain_demo",
    proof_type: str = "shell",
    proof_evidence: str = "uid=0(root) gid=0(root)",
    requested: int = 3,
    status: str = "pass",
    include_pcap: bool = True,
    pcap_reason_code: str = "pcap_placeholder_unavailable",
) -> Path:
    chain_dir = run_dir / "exploits" / chain_name
    chain_dir.mkdir(parents=True, exist_ok=True)

    execution_logs: list[str] = []
    attempts: list[dict[str, object]] = []
    for idx in range(1, requested + 1):
        log_path = chain_dir / f"execution_log_{idx}.txt"
        log_text = (
            f"attempt={idx}\n"
            "status=pass\n"
            f"proof_type={proof_type}\n"
            f"proof_evidence={proof_evidence}\n"
        )
        _ = log_path.write_text(log_text, encoding="utf-8")
        execution_logs.append(
            log_path.resolve().relative_to(run_dir.resolve()).as_posix()
        )
        attempts.append(
            {
                "attempt": idx,
                "status": "pass",
                "reason_code": "attempt_pass",
                "timestamp": "2026-02-17T00:00:00Z",
                "proof_type": proof_type,
                "proof_evidence": proof_evidence,
            }
        )

    network_capture = chain_dir / "network_capture.pcap"
    if include_pcap:
        _ = network_capture.write_bytes(b"pcap-bytes")

    _ = (chain_dir / "poc_sha256.txt").write_text("a" * 64 + "\n", encoding="utf-8")

    bundle: dict[str, object] = {
        "schema_version": "exploit-evidence-v1",
        "chain_id": "ER-e50_v3.0.1:test",
        "generated_at": "2026-02-17T00:00:00Z",
        "reproducibility": {
            "attempted": requested,
            "passed": requested,
            "reason_code": "repro_pass",
            "requested": requested,
            "status": status,
        },
        "attempts": attempts,
        "artifacts": {
            "execution_logs": execution_logs,
            "network_capture": network_capture.resolve()
            .relative_to(run_dir.resolve())
            .as_posix(),
            "poc_sha256": (chain_dir / "poc_sha256.txt")
            .resolve()
            .relative_to(run_dir.resolve())
            .as_posix(),
        },
        "pcap": {
            "status": "placeholder" if not include_pcap else "captured",
            "reason_code": pcap_reason_code,
        },
    }
    _ = (chain_dir / "evidence_bundle.json").write_text(
        json.dumps(bundle, indent=2, sort_keys=True, ensure_ascii=True) + "\n",
        encoding="utf-8",
    )
    return chain_dir


def test_verify_exploit_meaningfulness_ok_shell_signal(tmp_path: Path) -> None:
    run_dir = tmp_path / "run"
    _ = _write_chain_bundle(run_dir)

    res = _run_verifier(run_dir)
    assert res.returncode == 0
    assert res.stdout.startswith("[OK] exploit meaningfulness verified:")


def test_verify_exploit_meaningfulness_fails_marker_only_evidence(
    tmp_path: Path,
) -> None:
    run_dir = tmp_path / "run"
    _ = _write_chain_bundle(
        run_dir,
        proof_type="shell",
        proof_evidence="SCOUT_MARKER\necho marker",
    )

    res = _run_verifier(run_dir)
    assert res.returncode != 0
    assert "[FAIL] marker_only_evidence:" in res.stdout


def test_verify_exploit_meaningfulness_fails_invalid_proof_type(tmp_path: Path) -> None:
    run_dir = tmp_path / "run"
    _ = _write_chain_bundle(run_dir, proof_type="banner")

    res = _run_verifier(run_dir)
    assert res.returncode != 0
    assert "[FAIL] proof_type_invalid:" in res.stdout


def test_verify_exploit_meaningfulness_fails_repro_incomplete(tmp_path: Path) -> None:
    run_dir = tmp_path / "run"
    _ = _write_chain_bundle(run_dir, requested=2)

    res = _run_verifier(run_dir)
    assert res.returncode != 0
    assert "[FAIL] repro_incomplete:" in res.stdout


def test_verify_exploit_meaningfulness_fails_pcap_missing_without_placeholder(
    tmp_path: Path,
) -> None:
    run_dir = tmp_path / "run"
    _ = _write_chain_bundle(
        run_dir,
        include_pcap=False,
        pcap_reason_code="pcap_missing_unknown",
    )

    res = _run_verifier(run_dir)
    assert res.returncode != 0
    assert "[FAIL] pcap_missing:" in res.stdout


def test_verify_exploit_meaningfulness_allows_placeholder_reason_code(
    tmp_path: Path,
) -> None:
    run_dir = tmp_path / "run"
    _ = _write_chain_bundle(
        run_dir,
        include_pcap=False,
        pcap_reason_code="pcap_placeholder_unavailable",
    )

    res = _run_verifier(run_dir)
    assert res.returncode == 0
    assert "pcap_placeholder_allowed=1" in res.stdout


def test_verify_exploit_meaningfulness_fails_missing_bundle(tmp_path: Path) -> None:
    run_dir = tmp_path / "run"
    chain_dir = run_dir / "exploits" / "chain_demo"
    chain_dir.mkdir(parents=True, exist_ok=True)

    res = _run_verifier(run_dir)
    assert res.returncode != 0
    assert "[FAIL] missing_exploit_bundle:" in res.stdout


def test_verify_exploit_meaningfulness_pass_status_allows_declared_policy(
    tmp_path: Path,
) -> None:
    run_dir = tmp_path / "run"
    chain_dir = _write_chain_bundle(run_dir, status="pass")
    bundle_path = chain_dir / "evidence_bundle.json"
    bundle = cast(
        dict[str, object], json.loads(bundle_path.read_text(encoding="utf-8"))
    )
    attempts = cast(list[object], bundle["attempts"])
    first_attempt = cast(dict[str, object], attempts[0])
    first_attempt["status"] = "fail"
    reproducibility = cast(dict[str, object], bundle["reproducibility"])
    reproducibility["policy"] = {
        "mode": "allow_declared_partial_pass",
        "reason_code": "lab_policy_override",
    }
    _ = bundle_path.write_text(
        json.dumps(bundle, indent=2, sort_keys=True, ensure_ascii=True) + "\n",
        encoding="utf-8",
    )

    res = _run_verifier(run_dir)
    assert res.returncode == 0
    assert res.stdout.startswith("[OK] exploit meaningfulness verified:")
