#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import re
from pathlib import Path
from typing import cast

_ALLOWED_PROOF_TYPES = frozenset({"shell", "arbitrary_read", "arbitrary_write"})
_ALLOWED_PCAP_PLACEHOLDER_REASON = "pcap_placeholder_unavailable"


class VerificationError(ValueError):
    reason_code: str
    detail: str

    def __init__(self, reason_code: str, detail: str) -> None:
        self.reason_code = reason_code
        self.detail = detail
        super().__init__(f"{reason_code}: {detail}")


def _as_object(value: object, *, path: str) -> dict[str, object]:
    if not isinstance(value, dict):
        raise VerificationError("invalid_contract", f"{path} must be object")
    src = cast(dict[object, object], value)
    out: dict[str, object] = {}
    for key, item in src.items():
        out[str(key)] = item
    return out


def _load_json_object(path: Path, *, reason_code: str) -> dict[str, object]:
    try:
        raw = cast(object, json.loads(path.read_text(encoding="utf-8")))
    except Exception as exc:
        raise VerificationError(reason_code, f"invalid JSON: {path}: {exc}") from exc
    return _as_object(raw, path=str(path))


def _require_int(obj: dict[str, object], key: str, *, path: str) -> int:
    value = obj.get(key)
    if not isinstance(value, int):
        raise VerificationError("invalid_contract", f"{path}.{key} must be int")
    return value


def _require_str(obj: dict[str, object], key: str, *, path: str) -> str:
    value = obj.get(key)
    if not isinstance(value, str) or not value:
        raise VerificationError(
            "invalid_contract", f"{path}.{key} must be non-empty string"
        )
    return value


def _is_run_relative_path(path: str) -> bool:
    if not path:
        return False
    if path.startswith("/"):
        return False
    if re.match(r"^[A-Za-z]:\\", path):
        return False
    return True


def _resolve_run_relative_path(
    run_dir: Path,
    rel_path: str,
    *,
    field_path: str,
    reason_code: str,
) -> Path:
    if not _is_run_relative_path(rel_path):
        raise VerificationError(
            "invalid_contract", f"{field_path} must be run-relative path: {rel_path!r}"
        )
    candidate = (run_dir / rel_path).resolve()
    run_root = run_dir.resolve()
    try:
        _ = candidate.relative_to(run_root)
    except ValueError as exc:
        raise VerificationError(
            "invalid_contract", f"{field_path} escapes run_dir: {rel_path!r}"
        ) from exc
    if not candidate.exists():
        raise VerificationError(
            reason_code, f"missing path at {field_path}: {rel_path!r}"
        )
    return candidate


def _iter_chain_dirs(run_dir: Path) -> list[Path]:
    exploits_dir = run_dir / "exploits"
    if not exploits_dir.is_dir():
        raise VerificationError("missing_exploit_bundle", "missing directory: exploits")
    chain_dirs = sorted(
        [
            p
            for p in exploits_dir.iterdir()
            if p.is_dir() and p.name.startswith("chain_")
        ],
        key=lambda p: p.name,
    )
    if not chain_dirs:
        raise VerificationError(
            "missing_exploit_bundle", "no chain_* directories under exploits"
        )
    return chain_dirs


def _merge_attempt_evidence_text(
    bundle: dict[str, object], attempt: dict[str, object]
) -> str:
    parts: list[str] = []
    for key in ("proof_evidence", "reason_code", "status"):
        value = attempt.get(key)
        if isinstance(value, str) and value:
            parts.append(value)

    runtime_any = bundle.get("runtime")
    if isinstance(runtime_any, dict):
        runtime = cast(dict[str, object], runtime_any)
        for key in ("setup_error", "cleanup_error"):
            value = runtime.get(key)
            if isinstance(value, str) and value:
                parts.append(value)
    return "\n".join(parts)


def _contains_marker_only_evidence(text: str) -> bool:
    if not text.strip():
        return True
    normalized = text.strip().lower()
    lowered = text.lower()

    marker_line = bool(
        re.fullmatch(r"\s*(?:scout_marker|marker|echo\s+marker)\s*", normalized)
    )
    has_marker = (
        "scout_marker" in lowered
        or bool(re.search(r"\becho\s+marker\b", lowered))
        or marker_line
    )

    if not has_marker:
        return False

    has_context = bool(
        re.search(r"uid=", lowered)
        or re.search(r"\bwhoami\b", lowered)
        or re.search(r"(?:^|[^a-z0-9_])id(?:[^a-z0-9_]|$)", lowered)
        or re.search(
            r"\b(nonce|challenge|readback|verify|sha256|hash|write|read)\b", lowered
        )
    )
    return not has_context


def _validate_shell_evidence(text: str, *, chain_name: str, attempt_idx: int) -> None:
    lowered = text.lower()
    command_signal = bool(
        re.search(r"uid=", lowered)
        or re.search(r"\bwhoami\b", lowered)
        or re.search(r"(?:^|[^a-z0-9_])id(?:[^a-z0-9_]|$)", lowered)
    )
    nonce_signal = bool(
        re.search(r"\b(nonce|challenge)\b", lowered)
        and re.search(r"\b(command|exec|executed|output|echoed)\b", lowered)
    )
    if not command_signal and not nonce_signal:
        raise VerificationError(
            "marker_only_evidence",
            f"{chain_name} attempt[{attempt_idx}] shell proof missing command execution signal",
        )


def _validate_arbitrary_read_evidence(
    text: str, *, chain_name: str, attempt_idx: int
) -> None:
    lowered = text.lower()
    if "index.html" in lowered and not re.search(
        r"\b(sha256|hash|/etc/|passwd|shadow)\b", lowered
    ):
        raise VerificationError(
            "marker_only_evidence",
            f"{chain_name} attempt[{attempt_idx}] arbitrary_read proof is static-public token only",
        )

    has_non_trivial_read = bool(
        re.search(r"/etc/", lowered)
        or re.search(r"\b(passwd|shadow|config|nvram)\b", lowered)
        or re.search(r"\b(sha256|hash|readback|bytes|content)\b", lowered)
        or re.search(r"\b(cat|head)\b", lowered)
    )
    if not has_non_trivial_read:
        raise VerificationError(
            "marker_only_evidence",
            f"{chain_name} attempt[{attempt_idx}] arbitrary_read proof missing non-trivial read signal",
        )


def _validate_arbitrary_write_evidence(
    text: str, *, chain_name: str, attempt_idx: int
) -> None:
    lowered = text.lower()
    has_write_signal = bool(
        re.search(r"\b(write|wrote|create|created|modify|modified|append)\b", lowered)
    )
    has_verify_signal = bool(
        re.search(
            r"\b(readback|verify|verified|pre|post|before|after|sha256|hash)\b", lowered
        )
    )
    if not has_write_signal or not has_verify_signal:
        raise VerificationError(
            "marker_only_evidence",
            f"{chain_name} attempt[{attempt_idx}] arbitrary_write proof requires write+verify indicators",
        )


def _load_execution_logs(
    run_dir: Path,
    chain_dir: Path,
    bundle: dict[str, object],
    requested: int,
) -> list[str]:
    logs: list[str] = []

    artifacts_any = bundle.get("artifacts")
    if isinstance(artifacts_any, dict):
        artifacts = cast(dict[str, object], artifacts_any)
        logs_any = artifacts.get("execution_logs")
        if isinstance(logs_any, list):
            for idx, rel_any in enumerate(cast(list[object], logs_any)):
                if not isinstance(rel_any, str) or not rel_any:
                    raise VerificationError(
                        "invalid_contract",
                        f"{chain_dir.name} artifacts.execution_logs[{idx}] must be non-empty string",
                    )
                log_path = _resolve_run_relative_path(
                    run_dir,
                    rel_any,
                    field_path=f"{chain_dir.name}.artifacts.execution_logs[{idx}]",
                    reason_code="invalid_contract",
                )
                if not log_path.is_file():
                    raise VerificationError(
                        "invalid_contract",
                        f"{chain_dir.name} artifacts.execution_logs[{idx}] must point to file",
                    )
                logs.append(log_path.read_text(encoding="utf-8", errors="replace"))

    if logs:
        return logs

    for idx in range(1, requested + 1):
        log_path = chain_dir / f"execution_log_{idx}.txt"
        if not log_path.is_file():
            raise VerificationError(
                "invalid_contract",
                f"{chain_dir.name} missing fallback execution log: {log_path.name}",
            )
        logs.append(log_path.read_text(encoding="utf-8", errors="replace"))
    return logs


def _validate_reproducibility(
    bundle: dict[str, object],
    *,
    chain_name: str,
    attempts: list[dict[str, object]],
) -> None:
    reproducibility = _as_object(
        bundle.get("reproducibility"), path=f"{chain_name}.reproducibility"
    )
    requested = _require_int(
        reproducibility, "requested", path=f"{chain_name}.reproducibility"
    )
    if requested < 3:
        raise VerificationError(
            "repro_incomplete",
            f"{chain_name} reproducibility.requested must be >= 3",
        )
    if len(attempts) != requested:
        raise VerificationError(
            "repro_incomplete",
            f"{chain_name} attempts length {len(attempts)} != requested {requested}",
        )

    status = reproducibility.get("status")
    if status is not None and not isinstance(status, str):
        raise VerificationError(
            "invalid_contract",
            f"{chain_name}.reproducibility.status must be string if present",
        )

    if status == "pass":
        all_pass = all(attempt.get("status") == "pass" for attempt in attempts)
        if all_pass:
            return

        policy_any = reproducibility.get("policy")
        if not isinstance(policy_any, dict):
            raise VerificationError(
                "repro_incomplete",
                f"{chain_name} pass reproducibility requires all attempts pass or deterministic policy",
            )
        policy = cast(dict[str, object], policy_any)
        reason_code = policy.get("reason_code")
        mode = policy.get("mode")
        if (
            not isinstance(reason_code, str)
            or not reason_code
            or not isinstance(mode, str)
            or not mode
        ):
            raise VerificationError(
                "invalid_contract",
                f"{chain_name}.reproducibility.policy must include mode and reason_code",
            )


def _validate_pcap_linkage(
    run_dir: Path, bundle: dict[str, object], *, chain_name: str
) -> str:
    artifacts = _as_object(bundle.get("artifacts"), path=f"{chain_name}.artifacts")
    capture_rel = _require_str(
        artifacts, "network_capture", path=f"{chain_name}.artifacts"
    )

    capture_path = (run_dir / capture_rel).resolve()
    run_root = run_dir.resolve()
    try:
        _ = capture_path.relative_to(run_root)
    except ValueError as exc:
        raise VerificationError(
            "invalid_contract",
            f"{chain_name}.artifacts.network_capture escapes run_dir: {capture_rel!r}",
        ) from exc

    if capture_path.is_file():
        return "pcap_present"

    pcap = _as_object(bundle.get("pcap"), path=f"{chain_name}.pcap")
    reason = _require_str(pcap, "reason_code", path=f"{chain_name}.pcap")
    if reason == _ALLOWED_PCAP_PLACEHOLDER_REASON:
        return "pcap_placeholder_allowed"
    raise VerificationError(
        "pcap_missing",
        f"{chain_name} network_capture missing and placeholder reason not allowed",
    )


def _validate_chain_bundle(run_dir: Path, chain_dir: Path) -> str:
    bundle_path = chain_dir / "evidence_bundle.json"
    if not bundle_path.is_file():
        raise VerificationError(
            "missing_exploit_bundle",
            f"missing file: {chain_dir.name}/evidence_bundle.json",
        )

    bundle = _load_json_object(bundle_path, reason_code="invalid_contract")
    attempts_any = bundle.get("attempts")
    if not isinstance(attempts_any, list) or not attempts_any:
        raise VerificationError(
            "invalid_contract", f"{chain_dir.name}.attempts must be non-empty list"
        )
    attempts: list[dict[str, object]] = []
    for idx, item in enumerate(cast(list[object], attempts_any)):
        attempts.append(_as_object(item, path=f"{chain_dir.name}.attempts[{idx}]"))

    _validate_reproducibility(bundle, chain_name=chain_dir.name, attempts=attempts)
    requested = _require_int(
        _as_object(
            bundle.get("reproducibility"), path=f"{chain_dir.name}.reproducibility"
        ),
        "requested",
        path=f"{chain_dir.name}.reproducibility",
    )

    log_texts = _load_execution_logs(run_dir, chain_dir, bundle, requested)

    for idx, attempt in enumerate(attempts):
        attempt_idx = idx + 1
        proof_type = _require_str(
            attempt, "proof_type", path=f"{chain_dir.name}.attempts[{idx}]"
        )
        if proof_type not in _ALLOWED_PROOF_TYPES:
            raise VerificationError(
                "proof_type_invalid",
                f"{chain_dir.name} attempt[{attempt_idx}] invalid proof_type: {proof_type!r}",
            )

        evidence_text = _merge_attempt_evidence_text(bundle, attempt)
        if idx < len(log_texts):
            evidence_text = evidence_text + "\n" + log_texts[idx]

        if _contains_marker_only_evidence(evidence_text):
            raise VerificationError(
                "marker_only_evidence",
                f"{chain_dir.name} attempt[{attempt_idx}] marker-only evidence rejected",
            )

        if proof_type == "shell":
            _validate_shell_evidence(
                evidence_text, chain_name=chain_dir.name, attempt_idx=attempt_idx
            )
        elif proof_type == "arbitrary_read":
            _validate_arbitrary_read_evidence(
                evidence_text, chain_name=chain_dir.name, attempt_idx=attempt_idx
            )
        elif proof_type == "arbitrary_write":
            _validate_arbitrary_write_evidence(
                evidence_text, chain_name=chain_dir.name, attempt_idx=attempt_idx
            )

    return _validate_pcap_linkage(run_dir, bundle, chain_name=chain_dir.name)


def _verify_exploit_meaningfulness(run_dir: Path) -> tuple[int, int]:
    chain_dirs = _iter_chain_dirs(run_dir)
    pcap_placeholder_allowed_count = 0
    for chain_dir in chain_dirs:
        pcap_state = _validate_chain_bundle(run_dir, chain_dir)
        if pcap_state == "pcap_placeholder_allowed":
            pcap_placeholder_allowed_count += 1
    return len(chain_dirs), pcap_placeholder_allowed_count


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(
        description=(
            "Verify exploit evidence meaningfulness, reproducibility semantics, and pcap linkage."
        )
    )
    _ = parser.add_argument("--run-dir", required=True, help="Path to run directory")
    args = parser.parse_args(argv)

    run_dir_raw = getattr(args, "run_dir", None)
    if not isinstance(run_dir_raw, str) or not run_dir_raw:
        print("[FAIL] invalid_contract: --run-dir must be a non-empty path")
        return 1

    run_dir = Path(run_dir_raw).resolve()
    if not run_dir.is_dir():
        print(f"[FAIL] invalid_contract: run_dir is not a directory: {run_dir}")
        return 1

    try:
        chain_count, placeholder_count = _verify_exploit_meaningfulness(run_dir)
    except VerificationError as exc:
        print(f"[FAIL] {exc.reason_code}: {exc.detail}")
        return 1
    except Exception as exc:
        print(f"[FAIL] invalid_contract: unexpected verifier error: {exc}")
        return 1

    if placeholder_count > 0:
        print(
            f"[OK] exploit meaningfulness verified: {run_dir} "
            + f"(chains={chain_count}, pcap_placeholder_allowed={placeholder_count})"
        )
        return 0

    print(f"[OK] exploit meaningfulness verified: {run_dir} (chains={chain_count})")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
